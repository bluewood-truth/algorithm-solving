# 동적계획법 - 쉬운 계단 수 [🔗](https://www.acmicpc.net/problem/10844)

## 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.

세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

## 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

##### 입출력 예

| 입력 | 출력 |
| ---- | ---- |
| 2    | 17   |

## 풀이

처음 점화식을 세울 때 방향을 잘못 잡아서 많이 헤맸다.

한 자리 큰 계단수들을 만드는 방법은 직접 종이에 써보면 알기 쉽다. 끝자리 수를 +1, -1한 값을 끝에 붙여주면 된다.

예를 들어 N=1일때 `[1, 2, 3, 4, 5, 6, 7, 8, 9]`라면, N=2인 계단수를 만드는 방법은 다음과 같다.

> 1 -> 10, 12
>
> 2 -> 21, 23
>
> 3 -> 32, 34
>
> ...
>
> 9 -> 98

이때 끝자리 수가 0 혹은 9일 때는 다음 계단수를 하나밖에 만들지 못한다는 사실에 주의해야 한다.

N일때 생성되는 계단수는 N-1일때의 계단수의 끝자리 숫자에만 영향을 받는다. 따라서 매번 모든 계단수를 구할 필요 없이 끝자리 수별로 계단수의 갯수를 카운트하기만 하면 된다. 끝자리 수가 i인 계단수는 끝자리 수가 i-1, i+1인 계단수로부터 생성될 수 있으므로 점화식은 다음과 같다.

> f(N)[i] = f(N-1)[i-1] + f(N-1)[i+1]

이때 i=0인 계단수는 i=1인 계단수로부터, i=9인 계단수는 i=8인 계단수로부터밖에 생성될 수 없으므로 이 둘은 따로 예외처리를 해줘야 한다.

```python
N = int(input())
memo = [ [ 0 if i == 0 else 1 for i in range(10) ] ]
for _ in range(1, N):
    prev = memo[-1]
    now = [ 0  for _ in range(10) ]
    for i in range(10):
        if i == 0:
            now[i] += prev[1]
        elif i == 9:
            now[i] += prev[8]
        else:
            now[i] += (prev[i-1] + prev[i+1])
    memo.append(now)

print(sum(memo[-1]) % 1000000000)
```
