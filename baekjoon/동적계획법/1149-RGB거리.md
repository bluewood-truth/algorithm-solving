# 동적계획법 - RGB거리 [🔗](https://www.acmicpc.net/problem/1149)

## 문제

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

## 입력

첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

##### 입출력 예

| 입력                                           | 출력 |
| ---------------------------------------------- | ---- |
| 3 <br />26 40 83 <br />49 60 57 <br />13 89 99 | 96   |

## 풀이

단순히 순서대로 그때그때 고를 수 있는 가장 작은 값을 고른다면 다음과 같은 입력을 받았을 때 틀리게 된다.

> 2
>
> 1 2 3
>
> 1 100 200

이 경우 최소값은 G - R을 택한 3이지만, 만약 순서대로 작은 값을 고른다면 R - G를 골라 101이 되어버린다.

따라서 세 가지 경우를 따로 계산해야 한다. i번째 집을 칠할 경우의 점화식은 다음과 같다.

> i번째 R의 비용 = MIN(i-1번째 G의 비용, i-1번째 B의 비용) + i번째 R의 비용
>
> i번째 G의 비용 = MIN(i-1번째 R의 비용, i-1번째 B의 비용) + i번째 G의 비용
>
> i번째 B의 비용 = MIN(i-1번째 R의 비용, i-1번째 G의 비용) + i번째 B의 비용

```python
N = int(input())
costs = [ list(map(int, input().split())) for _ in range(N) ]

for i, cost in enumerate(costs):
    if i < 1:
        continue
    
    cost[0] += min(costs[i-1][1], costs[i-1][2])
    cost[1] += min(costs[i-1][0], costs[i-1][2])
    cost[2] += min(costs[i-1][0], costs[i-1][1])

print(min(costs[-1]))
```
