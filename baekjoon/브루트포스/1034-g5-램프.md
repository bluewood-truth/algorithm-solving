# 브루트포스 - 램프 [🔗](https://www.acmicpc.net/problem/1034)

## 문제

지민이는 각 칸마다 (1*1크기의 정사각형) 램프가 들어있는 직사각형 모양의 탁자를 샀다. 모든 램프는 켜져있거나 꺼져있다. 각 열의 아래에는 스위치가 하나씩 달려있는데, 이 스위치를 누를 때마다 그 열에 있는 램프의 상태가 바뀐다. (켜져있는 램프는 꺼지고, 꺼져있는 램프는 켜진다)

만약 어떤 행에 있는 램프가 모두 켜져있을 때, 그 행이 켜져있다고 말한다. 지민이는 스위치를 K번 누를 것이다. 서로다른 스위치 K개를 누르지 않아도 된다. 지민이는 스위치를 K번 눌러서 켜져있는 행을 최대로 하려고 한다.

지민이의 탁자에 있는 램프의 상태와 K가 주어졌을 때, 스위치를 K번 누른 후에 켜져있는 행의 최댓값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N과 M이 주어진다. N은 행의 개수이고, M은 열의 개수이다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 램프의 상태가 주어진다. 1이 켜져있는 상태이고, 0이 꺼져있는 상태이다. 마지막 줄에는 K가 주어진다. K는 1,000보다 작거나 같은 자연수 또는 0이다.

## 출력

첫째 줄에 문제의 정답을 출력한다.

##### 입출력 예

| 입력                               | 출력 |
| ---------------------------------- | ---- |
| 3 2<br />01<br />10<br />10<br />1 | 2    |

## 풀이

처음에는 모든 열을 켜고 끄는 조합을 DFS로 구하려고 했지만 이럴 경우 N * M<sup>K</sup> 만큼 반복을 수행해야 한다. 시간 초과가 날 게 뻔했다.

다음으로 생각한 풀이 방법은 아래와 같다.

1. 행과 행을 비교했을 때, 처음 상태가 서로 다르다면 스위치를 아무리 눌러도 두 행이 함께 켜질 수 없다. 반대로 처음 상태가 같다면 한쪽 행이 켜졌을 때 다른 행도 켜지게 된다.

2. 따라서 한 행의 입장에서, *그 행과 처음 상태가 같은 행의 갯수*가 그 *행의 램프를 전부 켰을 때 켜진 행 수*가 된다.

3. 그러므로 각 행을 순회하면서 

   - 스위치를 K번 눌러 그 행의 램프를 전부 켤 수 있는지 확인하고
   - 전부 켤 수 있다면 그 행과 같은 행의 갯수를 구한다

   이 과정을 통해 해당 행에서의 켜진 행 갯수를 구하여 최대값을 갱신한다.

그 행의 램프를 전부 켤 수 있는지 여부는

- 꺼진 램프의 갯수가 K보다 큰다
- (K - 꺼진 램프의 갯수)가 2로 나누어 떨어진다

이 두 조건을 만족하는지 아닌지로 판단한다. 두 번째 조건의 이유는 그 행의 램프를 전부 켰을 때 남은 K가 짝수라면 없는 거나 마찬가지이기 때문이다. (한 열만 껐다 켰다 하면 남은 횟수를 모두 사용할 수 있다)

```python
N, M = map(int, input().split())
lamps = [ list(input()) for _ in range(N) ]
K = int(input())

max_count = 0
for i in range(N):
    off_count = lamps[i].count('0')
    if off_count > K or (K - off_count) % 2 != 0:
        continue
    
    count = 0
    for j in range(N):
        if lamps[i] == lamps[j]:
            count += 1
    
    max_count = max(max_count, count)

print(max_count)
```

